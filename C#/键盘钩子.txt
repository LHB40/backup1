using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Threading;

namespace press
{
    public partial class Form1 : Form
    {
        [DllImport("user32.dll")]
        public static extern void mouse_event(int dwFlags,int dx,int dy,int cButtons,int dwExtraInfo);
        enum Mouseevent
        {
            MOUSEEVENTF_MOVE = 0x0001,     //移动鼠标 
            MOUSEEVENTF_LEFTDOWN = 0x0002, //模拟鼠标左键按下 
            MOUSEEVENTF_LEFTUP = 0x0004, //模拟鼠标左键抬起 
            MOUSEEVENTF_RIGHTDOWN = 0x0008, //模拟鼠标右键按下 
            MOUSEEVENTF_RIGHTUP = 0x0010, //模拟鼠标右键抬起 
            MOUSEEVENTF_MIDDLEDOWN = 0x0020, //模拟鼠标中键按下 
            MOUSEEVENTF_MIDDLEUP = 0x0040,// 模拟鼠标中键抬起 
            MOUSEEVENTF_ABSOLUTE = 0x8000, //标示是否采用绝对坐标
           }
        private KeyboardHookLib _keyboardHook = null;
        public Form1()
        {
            InitializeComponent();
            
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            CheckForIllegalCrossThreadCalls = false;
            Thread t1 = new Thread(new ThreadStart(move));
            t1.IsBackground = true;
            t1.Start();
            _keyboardHook = new KeyboardHookLib();
            _keyboardHook.InstallHook(this.OnKeyPress);
        }
        private void move()
        {
            Rectangle ws = Screen.GetWorkingArea(this);
            int wsw = ws.Width;
            int ww = wsw - 10;
            int count = 0;
            while (true)
            {
                Point pt = Control.MousePosition;
                if (pt.X>=ww)
                {
                    count++;
                }
                else
                {
                    count = 0;
                }
                if (count==2)
                {
                    click(50);
                }
                Thread.Sleep(500);
            }
        }
        private void click(int n)
        {
            int i = 0;
            Point p = Control.MousePosition;
            mouse_event((int)(Mouseevent.MOUSEEVENTF_MOVE| Mouseevent.MOUSEEVENTF_ABSOLUTE), 873*65535 / 1920, 454*65535 / 1080, 0, 0);
            while (i<n)
            {
                mouse_event((int)(Mouseevent.MOUSEEVENTF_ABSOLUTE | Mouseevent.MOUSEEVENTF_LEFTDOWN | Mouseevent.MOUSEEVENTF_LEFTUP), 0, 0, 0, 0);
                i++;
            }
            mouse_event((int)(Mouseevent.MOUSEEVENTF_MOVE | Mouseevent.MOUSEEVENTF_ABSOLUTE), p.X* 65535 / 1920,p.Y*  65535 / 1080, 0, 0);

        }
        public void OnKeyPress(KeyboardHookLib.HookStruct hookStruct, out bool handle)
        {
            handle = false; //预设不拦截任何键   
            if (hookStruct.vkCode==(int)Keys.LControlKey)// 截获左win(开始菜单键)  
            {
                handle = true;
                MessageBox.Show("a");
            }

        }
    }
    public class KeyboardHookLib
    {
        private const int WH_KEYBOARD_LL = 13; //键盘   

        //键盘处理事件委托 ,当捕获键盘输入时调用定义该委托的方法.   
        private delegate int HookHandle(int nCode, int wParam, IntPtr lParam);

        //客户端键盘处理事件   
        public delegate void ProcessKeyHandle(HookStruct param, out bool handle);

        //接收SetWindowsHookEx返回值   
        private static int _hHookValue = 0;

        //勾子程序处理事件   
        private HookHandle _KeyBoardHookProcedure;
        [StructLayout(LayoutKind.Sequential)]
        public class HookStruct
        {
            public int vkCode;
            public int scanCode;
            public int flags;
            public int time;
            public int dwExtraInfo;
        }

        //设置钩子   
        [DllImport("user32.dll")]
        private static extern int SetWindowsHookEx(int idHook, HookHandle lpfn, IntPtr hInstance, int threadId);

        //取消钩子   
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern bool UnhookWindowsHookEx(int idHook);

        //调用下一个钩子   
        [DllImport("user32.dll")]
        private static extern int CallNextHookEx(int idHook, int nCode, int wParam, IntPtr lParam);

        //获取当前线程ID   
        [DllImport("kernel32.dll")]
        private static extern int GetCurrentThreadId();

        //Gets the main module for the associated process.   
        [DllImport("kernel32.dll")]
        private static extern IntPtr GetModuleHandle(string name);

        private IntPtr _hookWindowPtr = IntPtr.Zero;

        //构造器   
        public KeyboardHookLib() { }

        //外部调用的键盘处理事件   
        private static ProcessKeyHandle _clientMethod = null;
        public void InstallHook(ProcessKeyHandle clientMethod)
        {
            _clientMethod = clientMethod;

            // 安装键盘钩子   
            if (_hHookValue == 0)
            {
                _KeyBoardHookProcedure = new HookHandle(OnHookProc);

                //_hookWindowPtr = GetModuleHandle(Process.GetCurrentProcess().MainModule.ModuleName);

                _hHookValue = SetWindowsHookEx(
                WH_KEYBOARD_LL,
                _KeyBoardHookProcedure,
                _hookWindowPtr,
                0);

                //如果设置钩子失败.   
                if (_hHookValue == 0) UninstallHook();
            }
        }

        //取消钩子事件   
        public void UninstallHook()
        {
            if (_hHookValue != 0)
            {
                bool ret = UnhookWindowsHookEx(_hHookValue);
                if (ret) _hHookValue = 0;
            }
        }

        //钩子事件内部调用,调用_clientMethod方法转发到客户端应用。   
        private static int OnHookProc(int nCode, int wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                //转换结构   
                HookStruct hookStruct = (HookStruct)Marshal.PtrToStructure(lParam, typeof(HookStruct));

                if (_clientMethod != null)
                {
                    bool handle = false;
                    //调用客户提供的事件处理程序。   
                    _clientMethod(hookStruct, out handle);
                    if (handle) return 1; //1:表示拦截键盘,return 退出   
                }
            }
            return CallNextHookEx(_hHookValue, nCode, wParam, lParam);
        }
    }
}
